To prevent a SAT solver from researching a symmetrical search tree, that was already solved
before, Symmetry Breaking Predicates can be added to the SAT
instance~\cite{sakallah2009symmetry}. SBPs can also be applied partially to the symmetry
group, called \textit{partial symmetry breaking}~\cite{sakallah2009symmetry}. Because
\textit{full symmetry breaking} sometimes costs a lot of time, most symmetrical search
spaces can be blocked by using a subset of the full SBP. There has been more research on
the efficiency of SBPs, such as~\cite{aloul2006efficient}\todo{More refs}.

\subsection{Terminology}
	As we build our research on the results of \cite{devriendt2012symmetry}, we will adopt
	their notation and terminology.
	Let a \emph{theory} $T$ be a SAT-instance in conjunctive normal form, i.e. a conjuction
	of clauses.
	Let $\Sigma(T)$ denote the set of variables in $T$.
	A literal is either of the form	$x$ or $\neg x$, where $x \in \Sigma(T)$.
	$\bar\Sigma(T)$ denotes the set of all possible literals of $T$.

	An \emph{assignment} of $T$ is an $\alpha \subseteq \bar\Sigma(T)$, such that at most
	one literal for each corresponding variable in $\Sigma(T)$ appears in $\alpha$.
	Thus an assignment where both $\{x, \neg x\} \subseteq \alpha$ is not allowed.
	\emph{Partial} and \emph{complete} assignments are distinguished.
	An assignment is considered \emph{complete} if it contains one literal for each $x \in \Sigma(T)$,
	otherwise it is a \emph{partial} assignment.

	A literal $l$ can be evaluated against an assignment $\alpha$: $l$ is \emph{true} if $l \in
	\alpha$, \emph{false} if $\neg l \in \alpha$ and \emph{undefined} otherwise.
	Clauses are either \emph{satisfied} or in \emph{conflict} with an assignment $\alpha$.
	A clause $C$ is \emph{satisfied} under the assignment $\alpha$,
	when at least one literal $l \in C$ is true.
	A \emph{conflict clause} $C$ is a clause which contains only literals that are false under the assignment.
	Additionally, $C$ can be a \emph{unit clause} if all literals are false, except one.

	A SAT-solver looks for a complete assignment such that all clauses in $T$ are satisfied.
	Such an assignment is called a model for $T$.
	A theory $T$ is satisfiable if a model exists for $T$.
	Given a theory $T$, we consider a clause $c$ a \emph{logical consequence} of $T$ iff
	$T \wedge c$ is satisfied for every model of $T$, this is denoted as $T \models c$.
	A theory $T'$ is a logical consequence of $T$, if all clauses in $T'$ are logical
	consequences of $T$.

	The SAT solver implemented by \cite{devriendt2012symmetry} uses the principle of \emph{Conflict Driven Clause Learning}, hence it is a CDCL SAT solver \cite{zhang2001efficient}.
	For each step of the solver, it assigns a value to an unassigned variable and adds the corresponding literal to the assignment.
	Because of this assignment, some clauses may become unit clauses, in which a literal must be satisfied
	or a conflict clause will result.
	In the \emph{unit propagation phase} the solver assigns these \emph{propagated literals} $l$ to true
	and the unit clauses are added as \emph{explanation clauses}, $expl(l)$.
	Such a solver has as state a triple $(\alpha, \delta, expl)$,
	where $\delta\subseteq \alpha$ are the \emph{choice literals} that are freely assigned between propagations,
	thus $\alpha \setminus \delta$ are the \emph{propagated literals}.
	
	When at some point a literal $l$ would be propagated while $\neg l$ is already true under the current assignment, this causes a conflict.
	If a conflict arises the CDCL SAT solver constructs a \emph{learned clause} using the explanation clauses $expl(l)$ causing the conflict.
	By adding this learned clause $C$ to the theory $T \cup C$ the solver prevents them from occurring again,
	and because $T \models C$ it does not affect the set of satisfying assignments.

	Consider a permutation $\sigma$ of $\bar\Sigma(T)$,
	$\sigma$ is called a symmetry if and only if:
	\begin{enumerate}
		\item $\sigma(\neg x) = \neg(\sigma( x ))$
		\item $\sigma(\alpha )$ is a model for $T$ $\Leftrightarrow$ $\alpha$ is a model for $T$
	\end{enumerate}

	A crucial theorem concerning symmetries is that for any clause $c$ that is a logical consequence of the theory $T$,
	$\sigma(c)$ is also a logical consequence.
	This can be used in clause learning to also add symmetric clauses to the learned clauses.\\

	\begin{proposition}
		\label{prop:symmetric_clause_learning}
		Let $\sigma$ be a symmetry of a theory $T$ and $c$ a clause.
		\begin{equation}
			T \models c \quad \implies \quad T \models \sigma( c )
		\end{equation}
	\end{proposition}

\subsection{Static Symmetry Breaking}
	Static symmetry breaking algorithms modify the input of the SAT solver, but do not
	adjust the solver itself~\cite{sakallah2009symmetry}.

	These solvers work by adding additional, symmetry breaking, predicates to a CNF 
	formula. Such a predicate acts like some filter, reducing the search space to only 
	non-symmetric regions. The symmetry breaker does this without changing the 
	satisfiability of the CNF formula as described \cite{aloul2003shatter}.

	Symmetry breaking can only be effective if the overhead of calculating symmetries and
	adding the symmetry breaking predicates takes significantly less time then the time it
	saves of the problem solving process. In order to limit the time needed for the static
	symmetry breaking, and the effort needed by the solver when evaluating all these
	additional predicates, it is often feasible to not break \emph{all} but \emph{enough} 
	symmetries as proposed by \cite{aloul2003shatter}.
	
	One, often used, static symmetry breaker is \cite{aloul2003shatter}. This symmetry
	breaker can also be used as a preprocessor for a dynamic symmetry breaker.
	\todo{cite needed}

\subsection{Dynamic Symmetry Breaking}
	Dynamic symmetry breaking algorithms modify the SAT solver to search for local
	symmetries during runtime. Contributions to dynamic symmetry breaking have not been
	numerous in SAT such as \cite{sabharwal2005symchaff}. In the field of Constraint Satisfaction
	Problems (CSP), dynamic symmetry breaking has had more contributions.
	In theory, the techniques developed in that field could be translated to the SAT domain.

	One theoretical approach in dynamic symmetry breaking would be to exploit symmetries in
	a theory to learn more clauses.
	Every time the solver learns a clause $c$, $\sigma(c)$ could also be learned, according
	to proposition \ref{prop:symmetric_clause_learning}.
	This however is often not feasible, as it would add too many clauses to the theory.

	The alternative approach, which is taken by the authors of
	\cite{devriendt2012symmetry}, is to propagate symmetrical literals.
	The idea is that given a theory $T$, a partial assignment $\alpha$ and a symmetry
	$\sigma$ of $T \cup \alpha$, proposition \ref{prop:symmetric_clause_learning} implies
	that for any literal $l$:

	\begin{equation}
		T \cup \alpha \vdash l \quad
		\implies
		\quad T \cup \alpha \vdash \sigma(l)
	\end{equation}

	Thus, when the solver propagates a literal $l$, $\sigma(l)$ can also be propagated.
	\todo{what about $\sigma^2(l)$\ldots}.

	The challenge with this approach is to find symmetries of $T \cup \alpha$ in a
	reasonable time.
	To this end, the authors of \cite{devriendt2012symmetry} introduced the notion of
	\emph{weak activity}.
	Weakly active symmetries can be used to propagate symmetrical literals.
	Weak activity is defined as follows:\\

	\begin{definition}
		\todoi{\ldots}
	\end{definition}


\todoi{Finish background (from De Vriendt paper) and explain his algorithm
so that we can relate how we change it.}
